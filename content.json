{"meta":{"title":"Ansen's blog","subtitle":null,"description":"������һ���黳��ѧϰ��Ӧֹͣ��","author":"Ansen zhang","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-04-08T09:57:41.357Z","updated":"2018-04-08T09:55:40.982Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-08T09:57:41.362Z","updated":"2018-04-08T09:55:40.983Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RxJava 2.x 使用总结二","slug":"RxJava 2.x-使用总结二","date":"2018-04-10T09:42:21.000Z","updated":"2018-04-11T10:39:55.640Z","comments":true,"path":"2018/04/10/RxJava 2.x-使用总结二/","link":"","permalink":"http://yoursite.com/2018/04/10/RxJava 2.x-使用总结二/","excerpt":"","text":"传送门:RxJava 2.x 使用总结&lt;一&gt; intervalinterval操作符是每隔一段时间就产生一个数字，这些数字从0开始，一次递增1直至无穷大，这个间隔时间可以设置，时间单位也可以设置。12345678System.out.println(\"Thread : \"+Thread.currentThread().getName());final Observable&lt;Long&gt; observable = Observable.interval(1, TimeUnit.SECONDS);observable.subscribe(new Consumer&lt;Long&gt;() &#123;@Overridepublic void accept(Long value) throws Exception &#123; System.out.println(\"Consumer.accept : value = \"+value+\" , Thread = \"+Thread.currentThread().getName());&#125;&#125;); 上面的代码执行结果为: Thread : main Consumer.accept : value = 0 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 1 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 2 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 3 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 4 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 5 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 6 , Thread = RxComputationThreadPool-1 ...此处省略N行打印 通过上面打印我们可以看到使用interval(…)方法，会按照该方法传递的参数值，第一个参数为时间数值，第二个参数为单位，上面的例子为，每个一秒产生一个事件，并传递数值，其数值是从0开始 递增1的，而且是会无穷大的递增。 然后细心的人可能会发现，上面的打印我是多加了一个对线程名字的打印，我们发现，我们在主线程中建立订阅关系，然后事件的接受消费是在一个名字为RxComputationThreadPool-1中执行的，其实这个线程就是一个子线程，其实很正常啊，我们在项目开发中，执行定时任务或者或者间隔任务，其实都是一种耗时任务，会阻塞的，所以都会放在子线程中去执行的。 take方法妙用结合上面的interval方法，我们在添点油加点醋。我们先来看个例子，应该就最能清楚take的具体作用了。12345678System.out.println(\"Thread : \" + Thread.currentThread().getName());final Observable&lt;Long&gt; observable = Observable.interval(1,TimeUnit.SECONDS).take(5);observable.subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long value) throws Exception &#123; System.out.println(\"Consumer.accept : value = \" + value+ \" , Thread = \" + Thread.currentThread().getName()); &#125;&#125;); 我们可以看到，我们调用了take(5)方法，传递了一个参数5。我们来直接看看运行结果吧。 Thread : main Consumer.accept : value = 0 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 1 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 2 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 3 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 4 , Thread = RxComputationThreadPool-1 我们可以看到，我们运行结果只打印了五个数值，从0-4，也就是我们调用take(5),其实起作用，大家也不言而喻了吧。 重复发送的repeat再接上面的例子，我们再继而调用一下repeat方法，看看会有什么结果呢？12345678System.out.println(\"Thread : \"+Thread.currentThread().getName());final Observable&lt;Long&gt; observable = Observable.interval(1, TimeUnit.SECONDS).take(4).repeat(2);observable.subscribe(new Consumer&lt;Long&gt;() &#123;@Overridepublic void accept(Long value) throws Exception &#123; System.out.println(\"Consumer.accept : value = \"+value+\" , Thread = \"+Thread.currentThread().getName());&#125;&#125;); 运行结果会如何呢？ Thread : main Consumer.accept : value = 0 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 1 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 2 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 3 , Thread = RxComputationThreadPool-1 Consumer.accept : value = 0 , Thread = RxComputationThreadPool-2 Consumer.accept : value = 1 , Thread = RxComputationThreadPool-2 Consumer.accept : value = 2 , Thread = RxComputationThreadPool-2 Consumer.accept : value = 3 , Thread = RxComputationThreadPool-2 由此可见，打印0-3重复了2一遍，那也就是我们调用repeat(2)其到了作用，我们知道不调用这个方法，我们只会打印一遍。 range方法发送特定的整数序列 range可以创建发射特定整数序列的 Observable。 range( int start , int end ) //start :开始的值 ， end ：结束的值 要求： end &gt;= start 123456Observable.range(1, 5).subscribe(new Consumer&lt;Integer&gt;() &#123;@Overridepublic void accept(Integer value) throws Exception &#123; System.out.println(\"Consumer.accept : value = \"+value);&#125;&#125;); 看看执行结果： Consumer.accept : value = 1 Consumer.accept : value = 2 Consumer.accept : value = 3 Consumer.accept : value = 4 Consumer.accept : value = 5 很明显，打印了从1-5的连续的整数序列。 flatMap 方法flatMap是变换操作符，使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后flatMap合并这些Observable发射的数据，最后将合并后的结果当作它自己的数据序列发射。 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;@Overridepublic void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3);&#125;&#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer value)throws Exception &#123; System.out.println(\"flatMap.apply.value = \"+value); if(value ==1)&#123; return Observable.just(\"One\"); &#125;else if(value ==2)&#123; return Observable.just(\"Two\"); &#125;else if(value ==3)&#123; return Observable.just(\"Three\"); &#125;else&#123; return Observable.just(\"Unknow\"); &#125; &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(\"Consumer.accept : content = \"+content); &#125;&#125;); 我们来看看执行结果吧： flatMap.apply.value = 1 Consumer.accept : content = One flatMap.apply.value = 2 Consumer.accept : content = Two flatMap.apply.value = 3 Consumer.accept : content = Three 通过结果，表面上看起来和map没有什么区别，map是可以在apply方法中直接返回转换后的数据，但是在flatMap中，是必须返回一个独立的ObservableSource对象的，我们知道Observable是继承自ObservableSource的。 我们就flatMap方法，我们再来看一个例子。 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer value)throws Exception &#123; System.out.println(\"flatMap.apply.value = \"+value); if(value ==1)&#123; return Observable.just(\"One\").delay(3, TimeUnit.SECONDS); &#125;else if(value ==2)&#123; return Observable.just(\"Two\").delay(2, TimeUnit.SECONDS); &#125;else if(value ==3)&#123; return Observable.just(\"Three\").delay(1, TimeUnit.SECONDS); &#125;else&#123; return Observable.just(\"Unknow\").delay(1, TimeUnit.SECONDS); &#125; &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(\"Consumer.accept : content = \"+content+\" , Thread : \"+Thread.currentThread().getName()); &#125;&#125;); 上面的代码，我们调用了delay，延时，我们先看结果。 flatMap.apply.value = 1 flatMap.apply.value = 2 flatMap.apply.value = 3 Consumer.accept : content = Three , Thread : RxNewThreadScheduler-3 Consumer.accept : content = Two , Thread : RxNewThreadScheduler-2 Consumer.accept : content = One , Thread : RxNewThreadScheduler-1 可以看到先打印了Three，然后是Two，最后是One，和之前的结果不一样了，而且线程都不同的子线程(如果不调用delay的话，默认都在订阅所在线程)，顺序改变了，可是有时候，我们需要延时，却并不要，改变执行顺序，依然需要One、Two、Three…这样的一个顺序，那么我们该怎么办？接下来我们需要讲讲concatMap操作。 concatMap我们上一个话题说到使用flatMap操作时候，如果最终转换出来的Observable是调用了delay的话且又都在不同的线程，如何去保证原始顺序呢？所以我们才需要concatMap这个方法，其实简答的来说，concatMap和flatMap的区别就在于，concatMap保证了其事件派发的顺序。 这里我们其他地方都不改动，直接把flatMap替换成concatMap再来看看结果吧。123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125;&#125;).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(Integer value)throws Exception &#123; System.out.println(\"flatMap.apply.value = \"+value); if(value ==1)&#123; return Observable.just(\"One\").delay(3, TimeUnit.SECONDS); &#125;else if(value ==2)&#123; return Observable.just(\"Two\").delay(2, TimeUnit.SECONDS); &#125;else if(value ==3)&#123; return Observable.just(\"Three\").delay(1, TimeUnit.SECONDS); &#125;else&#123; return Observable.just(\"Unknow\").delay(1, TimeUnit.SECONDS); &#125; &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(\"Consumer.accept : content = \"+content+\" , Thread : \"+Thread.currentThread().getName()); &#125;&#125;); 那么接下来，我们直接看看运行效果呗。 flatMap.apply.value = 1 Consumer.accept : content = One , Thread : RxComputationThreadPool-1 flatMap.apply.value = 2 Consumer.accept : content = Two , Thread : RxComputationThreadPool-2 flatMap.apply.value = 3 Consumer.accept : content = Three , Thread : RxComputationThreadPool-3 OK，结果非常明显，不管delay如何变化，都能保证了顺序。 fromIterable有这样一个使用场景，假设我们发射一个list格式的数据，Observer需要逐一去接收list中的数据并作出相应的操作，像这种场景我们该如何实现呢？ 不管三七二十一，我们先来看一段代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Observable.create(new ObservableOnSubscribe&lt;List&lt;String&gt;&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;List&lt;String&gt;&gt; emitter)throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.add(\"D\"); emitter.onNext(list); &#125;&#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(List&lt;String&gt; list) throws Exception &#123; return Observable.fromIterable(list); &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(\"Consumer.accept : content = \"+content); &#125;&#125;);Observable.create(new ObservableOnSubscribe&lt;List&lt;String&gt;&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;List&lt;String&gt;&gt; emitter)throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.add(\"D\"); emitter.onNext(list); &#125;&#125;).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(List&lt;String&gt; list) throws Exception &#123; return Observable.fromIterable(list); &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(\"Consumer.accept : content = \"+content); &#125;&#125;); 上面的代码，我们可以看到，我们发射一个list集合，然后我们使用拿到集合之后，使用flatMap重新进行了转换，我们发现我们直接调用了Observable的fromIterable方法，传入list集合，最后，我们在接收的时候，就跟遍历list集合一样，逐一的打印了list集合中的数据，但是当然你如果有其他的附件操作也是可以的。 与fromIterable异曲同工之妙的fromArray 其实效果是一样的，只不过，Observalbe原始发射的是一个数组，这里就不在讲述其使用方法了。 既然讲到数组集合了，那么我们接下来也应该说一说toList 了 toList这个就比较简单了，从字面上来说，无非就是把一组数据，转成一个集合？123456789Observable.just(\"item1\", \"item2\", \"item3\", \"item4\", \"item5\").toList().subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123;@Overridepublic void accept(List&lt;String&gt; list) throws Exception &#123; System.out.println(\"Consumer.accept : list = \"+list);&#125;&#125;); 就直接看结果吧。 Consumer.accept : list = [item1, item2, item3, item4, item5] 很显然，直接将一组数据转成了一个list发射。 背压 BackPressure背压产生的原因： 被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。在 Rxjava 1.x 版本很容易就会报错，使程序发生崩溃。 ... Caused by: rx.exceptions.MissingBackpressureException ... ... 我们知道在RxJava 1.x中是不支持背压的，但是在2.X之后支持背压了，可是在Observable和Observer依然还是不支持，不过2.X增加了Flowable（被观察者），Flowable （被观察者）和Subscriber （观察者）配合可以完美实现背压处理。 先来看一段不使用背压处理时候的代码。 12345678910Observable.interval(1, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long value) throws Exception &#123; Thread.sleep(1000); System.out.println(\"value : \"+value); &#125;&#125;); 这段代码中，发射器发射数据的频率为1毫秒，而消费者以1秒处理一个事件的能力在处理，很显然，这会导致RxJava对已经发射出去且未被处理的数据进行了缓存，都存在于内存中，这样一段代码在执行的时候并不会报错，因为这样的组合并不支持背压，并不会抛出MissingBackpressureException背压异常，但是这样的代码其实有很大的问题的。 存在延迟缓存的话，会导致无法即使处理关键、敏感、重要信息。 如果数据量不确定，可能比较大的情况下，都缓存在内存中的话，会占用大量的内存，是不明智的做法。 然后我们如何通过背压处理来解决呢？12345678910Flowable.interval(1, TimeUnit.MILLISECONDS).subscribeOn(Schedulers.io()).observeOn(Schedulers.newThread()).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long value) throws Exception &#123; Thread.sleep(1000); System.out.println(\"Consumer.accept: value = \"+value); &#125; &#125;); 我们知道RxJava 2.X中Flowable支持了背压，可是上面的代码然后就解决问题了吗?运行结果会如何呢？ io.reactivex.exceptions.OnErrorNotImplementedException: Can&apos;t deliver value 128 due to lack of requests ... ... Caused by: io.reactivex.exceptions.MissingBackpressureException: Can&apos;t deliver value 128 due to lack of requests 很明显发生了 MissingBackpressureException 异常 , 128 代表是 Flowable 最多缓存 128 个数据，缓存次超过 128 个数据，就会报错。可喜的是，Rxjava 已经给我们提供了解决背压的策略。 ###背压策略onBackpressureDrop### onBackpressureDrop() ：当缓冲区数据满 128 个时候，再新来的数据就会被丢弃，如果此时有数据被消费了，那么就会把当前最新产生的数据，放到缓冲区。简单来说 Drop 就是直接把存不下的事件丢弃。 1234567891011Flowable.interval(1, TimeUnit.MILLISECONDS).onBackpressureDrop().subscribeOn(Schedulers.io()).observeOn(Schedulers.newThread()).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long value) throws Exception &#123; Thread.sleep(1000); System.out.println(\"Consumer.accept: value = \"+value); &#125; &#125;); 上面的代码，我们调用了onBackpressureDrop()方法，然后来看看结果。 ... Consumer.accept: value = 124 Consumer.accept: value = 125 Consumer.accept: value = 126 Consumer.accept: value = 127 Consumer.accept: value = 96093 Consumer.accept: value = 96094 Consumer.accept: value = 96095 Consumer.accept: value = 96096 Consumer.accept: value = 96097 ... 我们发现发射器发射的 0 ~ 127 总共 128 个数据是连续的，下一个数据就是 96129 ， 128 ~ 96128 的数据被丢弃了。onBackpressureDrop的调用 一定要放在 interval 后面否则不会生效。 ###onBackpressureBuffer### onBackpressureBuffer：默认情况下缓存所有的数据，不会丢弃数据，这个方法可以解决背压问题，但是它有像 Observable 一样的缺点，缓存数据太多，占用太多内存。onBackpressureBuffer(int capacity) ：设置缓存队列大小，但是如果缓冲数据超过了设置的值，就会报错，发生崩溃。 示例:1234567891011Flowable.interval(1, TimeUnit.MILLISECONDS).onBackpressureBuffer(20).subscribeOn(Schedulers.io()).observeOn(Schedulers.newThread()).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long value) throws Exception &#123; Thread.sleep(1000); System.out.println(\"Consumer.accept: value = \"+value); &#125;&#125;); 执行结果: io.reactivex.exceptions.OnErrorNotImplementedException: Buffer is full···Caused by: io.reactivex.exceptions.MissingBackpressureException: Buffer is full通过日志可以看出，缓冲区已经满了，抛出了异常。 Subscriber + Flowable处理背压和Subscription.request(long count)方法先来看一段代码。1234567891011121314151617181920212223242526272829Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; System.out.println(\"subscribe\"); for (int i = 0; i&lt;201 ; i++) &#123; emitter.onNext(i); &#125; &#125;&#125;, BackpressureStrategy.DROP).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; System.out.println(\"onSubscribe\"); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext:integer = \"+integer); &#125; @Override public void onError(Throwable t) &#123; System.out.println(\"onError \"); &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete \"); &#125;&#125;); 上面的代码，有些人是不是觉得，会直接打印0-127的打印？可是万万没想到的是，只是打印了如下两个日志。 onSubscribe subscribe 那么如何才能接收到发射的事件，然后打印出来呢？那么就需要用到Subscription的request(…)方法了。那么Subscription从哪里来呢？细心的人可能发现了，在onSubscribe(Subscription s)回调方法中，传递了一个Subscription s对象，那么我们直接在这个回调方法中调用s.request(50);方法试试看有什么效果吧。123456789101112131415161718192021222324252627282930Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; System.out.println(\"subscribe\"); for (int i = 0; i&lt;201 ; i++) &#123; emitter.onNext(i); &#125; &#125;&#125;, BackpressureStrategy.DROP).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; System.out.println(\"onSubscribe\"); s.request(10); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext:integer = \"+integer); &#125; @Override public void onError(Throwable t) &#123; System.out.println(\"onError \"); &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete \"); &#125;&#125;); 可以看到，我们在onSubscribe回调方法中调用了s.request(10);来看看其结果吧！ onSubscribe subscribe onNext:integer = 0 onNext:integer = 1 onNext:integer = 2 onNext:integer = 3 onNext:integer = 4 onNext:integer = 5 onNext:integer = 6 onNext:integer = 7 onNext:integer = 8 onNext:integer = 9 结果我们发现，你请求多少个数据事件，就会给你发射多少个数据事件，这样我们才能接收到数据并消费数据。 那么我们拿到这个Subscription对象之后，在外部再调用一次request(10)呢？ onSubscribe subscribe onNext:integer = 0 onNext:integer = 1 onNext:integer = 2 onNext:integer = 3 onNext:integer = 4 onNext:integer = 5 onNext:integer = 6 onNext:integer = 7 onNext:integer = 8 onNext:integer = 9 onNext:integer = 10 onNext:integer = 11 onNext:integer = 12 onNext:integer = 13 onNext:integer = 14 onNext:integer = 15 onNext:integer = 16 onNext:integer = 17 onNext:integer = 18 onNext:integer = 19 我们发现我们是从第一次调用request(10)之后，又接收消费了从9-19的数据事件，那么我们从中得到的规律是，每次调用request(..)方法，都会从上一次发射的最后一个事件的下一个事件开发发送请求数量的事件。","categories":[],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://yoursite.com/tags/RxJava/"}]},{"title":"RxJava 2.x 使用总结<一>","slug":"RxJava 2.x 使用总结一","date":"2018-04-10T01:58:17.000Z","updated":"2018-04-11T10:58:28.314Z","comments":true,"path":"2018/04/10/RxJava 2.x 使用总结一/","link":"","permalink":"http://yoursite.com/2018/04/10/RxJava 2.x 使用总结一/","excerpt":"","text":"本文主要记录一下RxJava2.x的使用，其实网络上已经有很多关于RxJava的使用教程，以及原理剖析类的文章，其实我的理解大概也和那些文章中描述的也差不多，所以这里就不在过多去说类似的东西了。 在这里推荐一篇文章给大家，虽然是基于RxJava 1.X来写的，但是我觉得这是我目前见过写的比较清晰了然的一片文章，很适合初学者去对RxJava进行一番学习和使用。 给 Android 开发者的 RxJava 详解 基本使用添加依赖123456789implementation 'io.reactivex.rxjava2:rxjava:2.1.12'implementation 'io.reactivex.rxjava2:rxandroid:2.0.2'implementation 'org.reactivestreams:reactive-streams:1.0.2'implementation 'com.squareup.okhttp3:okhttp:3.10.0'implementation 'com.squareup.retrofit2:retrofit:2.4.0'implementation 'com.squareup.retrofit2:converter-gson:2.4.0'implementation 'com.squareup.okhttp3:logging-interceptor:3.10.0'implementation 'com.squareup.retrofit2:converter-scalars:2.4.0'implementation 'com.squareup.retrofit2:adapter-rxjava2:2.4.0' 当然，上面添加的依赖有点多，但是其实你如果只需要使用RxJava只需要添加如下两个依赖就行 。12implementation 'io.reactivex.rxjava2:rxjava:2.1.12'implementation 'org.reactivestreams:reactive-streams:1.0.2' 但是你如果想要在android上面使用的话，就必须再多加上如下这个依赖。1implementation 'io.reactivex.rxjava2:rxandroid:2.0.2' 我们知道现在主流用发就是，RxJava+OkHttp+Retrofit，这三者结合使用是让我们的代码更加简单有层次，提升性能有提升开发速度，所以你如果又要在你的项目中需要请求网络，需要传输json数据的话，不妨再加上如下几个依赖。123456implementation 'com.squareup.okhttp3:okhttp:3.10.0'implementation 'com.squareup.retrofit2:retrofit:2.4.0'implementation 'com.squareup.retrofit2:converter-gson:2.4.0'implementation 'com.squareup.okhttp3:logging-interceptor:3.10.0'implementation 'com.squareup.retrofit2:converter-scalars:2.4.0'implementation 'com.squareup.retrofit2:adapter-rxjava2:2.4.0' 使用create(…)创建Observablecreate(…)方法是Observable对象的一个静态方法，主要用于创建产生一个Observable被观察者对象。123456789final Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123; emitter.onNext(&quot;Hello!&quot;); emitter.onNext(&quot;RxJava&quot;); emitter.onNext(&quot;Hi!&quot;); emitter.onNext(&quot;Android&quot;); &#125;&#125;); 上面的代码我们使用create(…)方法创建了一个被观察者Observable，那么我们知道观察者Observer和被观察者Observable之间事件的订阅关系是通过subscribe(…)方法来实现的，一般来说，订阅事件是发生在观察者身上的，因为观察者需要关注订阅发生在被观察者身上的一系列事件，但是在RxJava中，为了方便链式的调用以及RxJava的架构，这个subscribe(…)方法声明在了Observable对象上，现在我们先来创建一个观察者Observer。123456789101112131415161718final Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable disposable) &#123; System.out.println(&quot;Observer.onSubscribe : isDisposable = &quot; +disposable.isDisposed()); &#125; @Override public void onNext(String content) &#123; System.out.println(&quot;Observer.onNext : content = &quot; +content); &#125; @Override public void onError(Throwable throwable) &#123; System.out.println(&quot;Observer.onError &quot;); &#125; @Override public void onComplete() &#123; System.out.println(&quot;Observer.onComplete &quot;); &#125;&#125;; Observer我们创建好了，我们发现需要Override四个方法。1234public void onSubscribe(Disposable disposable)；public void onNext(String content) ；public void onError(Throwable throwable)；public void onComplete()； 但是细心的就会发现，我们Observable持有的一个发射器ObservableEmitter，这个对象也有三个比较关键的方法。 不然发现，是onNext()、onError()、onComplete()三个方法，看起来是和Observer中其中的三个需要Override的方法是对应的。 这样我就把观察者Observer和被观察者Observable创建好了，接下来要做的就是使用subscribe(…)方法把他们关联起来。1observable.subscribe(observer); OK，这就把两者的关系给绑定起来了，另外要注意的是，这个方法一旦调用，也就是说，一旦注册订阅，被观察着的事件发射器就开发发射事件，接着观察者的方法就会被被调用。代码的运行结果吧！ Observer.onSubscribe : isDisposable = false Observer.onNext : content = Hello! Observer.onNext : content = RxJava Observer.onNext : content = Hi! Observer.onNext : content = Android 从上面的打印来看，当订阅成功后，会立马先调用Observer的onSubscribe方法，然后会依次按顺序打印了Hello!-&gt;RxJava-&gt;Hi!-&gt;Android 从上面的代码中，我们知道，和1.x想比，2.X多了一个Disposable，我们可以看到在onSubscribe()方法中会传递过来一个Disposable对象，那么这个Disposable其实可以看做是连接Observer和Observable的一个开关，拿到它之后，可以直接调用切断，来解除Observer对Observable的关注和订阅，但是这也意味着，Observer不在能收到订阅事件了，所以Disposable的dispose()方法就可以切断两者的事件驱动，当Disposable的isDisposed()方法返回false的时候，表明正常，可以发送接收事件，但是为true的时候，表明两者事件驱动被切断。 调用onComplete()会如何？我们发现上面的实例代码中，仅仅只是调用了onNext(…)方法触发了四个事件，然后Observer接收处理了相应的事件，我们稍微改动一下代码，然后在我们的代码中调用一下onComplete()看看会有什么效果呢？12345678910final Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;@Overridepublic void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123; emitter.onNext(&quot;Hello!&quot;); emitter.onNext(&quot;RxJava&quot;); emitter.onComplete(); emitter.onNext(&quot;Hi!&quot;); emitter.onNext(&quot;Android&quot;);&#125;&#125;); 我们看到，在subscribe(…)方法中，我在四个onNext()调用顺序之间加了一句代码，即调用了oComplete方法，然后我们再来执行一下代码，看看会有什么结果。 Observer.onSubscribe : isDisposable = false Observer.onNext : content = Hello! Observer.onNext : content = RxJava Observer.onComplete 结果，我们发现，我们只收到了调用onComplete()方法之前的两个onNext事件，然后就直接执行了Observer的onComplete()方法，由此可知，当调用发射器的onComplete()方法之后，后面的事件是无法再收到了，但是事件的发送还在继续。 简化的Consumer有时候我们觉得使用Observer比较复杂，我们知道Observer是一个接口，如果要实现Observer接口，那么必须覆盖其四个抽象方法，比如有些时候我们只关注订阅的事件，只对订阅的事件的发生做出相应的操作，那么一般我们只需要Override onNext(…){}即可。 如果说RxJava中两个重要的角色关系是观察者和被观察的关系的话，被观察者产生事件，观察者响应事件，那么是不是也可以理解为这是一种生产者和消费者的关系，很显然这么理解是可以的。 所以RxJava中有一个用起来比简单的Consumer，实现Consumer 接口只需要实现一个方法，即accept(…)，当然Observable和Consumer之间也是通过Observable的subscribe来建立订阅关系的，OK我们之间写一段代码来运行试试看。123456789101112131415161718final Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;@Overridepublic void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123; emitter.onNext(&quot;Hello!&quot;); emitter.onNext(&quot;RxJava&quot;); emitter.onComplete(); emitter.onNext(&quot;Hi!&quot;); emitter.onNext(&quot;Android&quot;);&#125;&#125;);final Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123; @Overridepublic void accept(String content) throws Exception &#123; System.out.println(&quot;Consumer.accept : content = &quot;+content);&#125;&#125;;final Disposable disposable = observable.subscribe(consumer); 我们的Observable没有变，还有前面创建的对象，我们来试试运行结果。 Consumer.accept : content = Hello! Consumer.accept : content = RxJava 我们发现Consumer的accept()方法只调用了两次，只打印了“Hello！” 和 “RxJava”，和使用Observer的不同之处在于，Observer会关注Observable的任何一个操作，比如，onError()、onComplete()方法，而Consumer就比较简单了，只需要关注和响应onNext(…)事件就行了，有时候我们可能就只需这样简单的场景，当然这是RxJava 2.x出现的特性。 但是我们还发现，使用订阅Consumer的时候，会直接返回一个Disposable对象。 事件的转换包装器map先不说map的功能，我们先直接看一段代码，再来谈谈map的功能。123456789101112131415161718192021Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123; emitter.onNext(100); emitter.onNext(200); emitter.onNext(300); emitter.onNext(400); &#125;&#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer num) throws Exception &#123; System.out.println(&quot;Function.apply : num = &quot;+num); return &quot;我得了&quot;+num+&quot;分&quot;; &#125;&#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(&quot;Consumer.accept : content = &quot;+content); &#125;&#125;); 运行结果: Function.apply : num = 100 Consumer.accept : content = 我得了100分 Function.apply : num = 200 Consumer.accept : content = 我得了200分 Function.apply : num = 300 Consumer.accept : content = 我得了300分 Function.apply : num = 400 Consumer.accept : content = 我得了400分 可以看到，是先执行了map节点中Function对象的apply方法，这个方法接收一个Integer类型的数据，然后返回一个String类型的数据，继apply(…)方法之后是Consumer的accept(…)方法，而accept收到的参数是一个String类型，其值就是通过Function对象的apply方法返回来的。 那么不难发现，我们可以把map节点中的Function看做一个工厂，把Integer泛型限定的Observable(Observable(Integer))转换成了String类型的Observable(Observable)。 其实我们把每个节点分开来写会更加清晰一点。123456789final Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123; emitter.onNext(100); emitter.onNext(200); emitter.onNext(300); emitter.onNext(400); &#125;&#125;); 不难发现，首先初始是一个Observable类型的，当我们调用起map方法之后就变成了Observable类型了。1234567final Observable&lt;String&gt; observable2 = observable.map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer num) throws Exception &#123; System.out.println(&quot;Function.apply : num = &quot;+num); return &quot;我得了&quot;+num+&quot;分&quot;; &#125;&#125;); 最后再调用了subscribe方法进行关联订阅。123456observable2.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(&quot;Consumer.accept : content = &quot;+content); &#125;&#125;); 所以通过上面的一个小例子，我们不难发现，map基本作用就是将一个 Observable 通过某种函数关系，转换为另一种 Observable，上面例子中就是把我们的 Integer 数据变成了 String 类型。 事件组合器zip1234567891011121314151617181920212223242526272829303132final Observable&lt;Integer&gt; integerObservable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123; emitter.onNext(100); emitter.onNext(80); emitter.onNext(60); &#125;&#125;); final Observable&lt;String&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123; emitter.onNext(&quot;优&quot;); emitter.onNext(&quot;良&quot;); emitter.onNext(&quot;及格&quot;); &#125;&#125;); final Observable&lt;String&gt; resultObservable = Observable.zip(integerObservable,stringObservable, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer score, String desc)throws Exception &#123; System.out.println(&quot;&lt;zip&gt;.BiFunction.apply : score = &quot;+score+&quot; , desc = &quot;+desc); return score +&quot; 分为 &quot;+ desc; &#125;&#125;);resultObservable.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String content) throws Exception &#123; System.out.println(&quot;Consumer.accept : content = &quot;+content); &#125;&#125;); 那么直接看结果。 &lt;zip&gt;.BiFunction.apply : score = 100 , desc = 优 Consumer.accept : content = 100 分为 优 &lt;zip&gt;.BiFunction.apply : score = 80 , desc = 良 Consumer.accept : content = 80 分为 良 &lt;zip&gt;.BiFunction.apply : score = 60 , desc = 及格 Consumer.accept : content = 60 分为 及格 我们发现，通过调用Observable的zip(…)方法，方法最后的以参数为一个BiFunction对象，很巧妙的将两个事件进行组合，组合成了一个新的Observable。 zip 组合事件的过程就是分别从integerObservable和stringObservable各取出一个事件来组合，并且一个事件只能被使用一次，组合的顺序是严格按照事件发送的顺序来进行的，所以上面的实例可以看到，100 永远和 “优”结合，80永远和“良”结合等。 那么会有一个问题，如果我在integerObservable中发送三个事件，在stringObservable发送一个或者两个，或者三个，甚至一个都不发呢?这种情况是如何执行的呢？不妨来来试试看吧，我们改动一下stringObservable里面的逻辑吧。1234567final Observable&lt;String&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123; emitter.onNext(&quot;优&quot;); emitter.onNext(&quot;良&quot;); &#125;&#125;); 执行结果如下。1234&lt;zip&gt;.BiFunction.apply : score = 100 , desc = 优Consumer.accept : content = 100 分为 优&lt;zip&gt;.BiFunction.apply : score = 80 , desc = 良Consumer.accept : content = 80 分为 良 我们发现少了一个60和”及格”的组合。然后我们全部去掉，什么都不发送呢？12345final Observable&lt;String&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123; &#125;&#125;); 再执行，我们发现，什么打印都没有。所以我们可以总结为最终接收到的事件数量是和发送事件最少的那个Observable发送器的发送事件数目相同，如果其中一个什么都没发送，那么什么事件都接收不到。","categories":[],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://yoursite.com/tags/RxJava/"}]},{"title":"使用Hexo+Github搭建个人博客","slug":"使用Hexo-Github搭建个人博客","date":"2018-04-09T03:47:12.000Z","updated":"2018-04-09T07:02:14.781Z","comments":true,"path":"2018/04/09/使用Hexo-Github搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/04/09/使用Hexo-Github搭建个人博客/","excerpt":"","text":"本篇不在介绍Hexo和Github以及Github pages相关的东西，直接介绍我搭建的每一个步骤，如果想要了解Hexo和Github这块的东西，可以自行去百度或者google了解。 搭建步骤 安装node.js 直接去官网下载即可。https://nodejs.org/en/, node.js在我们的博客搭建过程主要提供包管理服务， Node.js的包管理器npm，是全球最大的开源库生态系统。 安装Git 直接官网下载即可。https://git-scm.com/download/win Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地 处理任何或小或大的项目，版本控制。 进入Node.js的根目录，执行如下命令安装Hexonpm install hexo -g 在磁盘上创建一个目录用来存放Blog的所有文件 例如 E:\\blog\\MrByte 在步骤4中创建的目录中执行如下命令初始化Bloghexo init 安装依赖包npm install 测试-创建一个篇新的博客hexo new &quot;My New Post&quot; 启动服务并测试本地发布执行命令:hexo server在浏览器输入敲回车: http://localhost:4000 搭桥到github A、创建一个repository，其中[repository name]的格式必须如下: 例如: yourname.github.io 其中yourname部分必须和github账号名一致，否则无效。 B、打开git bash命令行窗口，配置github账号信息,执行如下两条命令git config --global user.name &quot;yourName&quot;git config --global user.email &quot;yourEmail&quot;把yourName改为github账号，把yourEmail改为注册Github用的邮箱即可。 C、在git bash命令窗口中执行如下命令创建SSHssh-keygen -t rsa -C &quot;youremail@example.com&quot;然后在生成的id_rsa.pub中复制其全部内容,双引号中的邮箱改为注册Github用的邮箱即可。 D、然后登入github，选择[Settings]-[SSH and GPG keys]-[New SSH key] 然后粘贴上述复制的SSH public key即可。 E、然后在git bash命令行中执行如下命令行进行验证ssh -T git@github.com F、在blog项目根目录中找到[_config.yml]文件，使用文本编辑器打开,每个字段的冒号后面都有一个空格。 deploy:type: gitrepository: https://ByteMr:******@github.com/ByteMr/ByteMr.github.io.gitbranch: master 上述repositoy字段中的地址中，冒号后后面出现*号，这里应该替换成你真实的github账号密码，ByteMr则为真实的github账号 上传到githubA、执行如下命令，这样才能将你写好的文章部署到github服务器上并让别人浏览到npm install hexo-deployer-git --saveB、发布 hexo clean hexo generate hexo deplo 测试是否发布成功浏览器输入： http://yourgithubname.github.io","categories":[],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]},{"title":"我的博客上线啦","slug":"我的博客上线啦","date":"2018-04-08T11:06:04.000Z","updated":"2018-04-09T01:20:37.927Z","comments":true,"path":"2018/04/08/我的博客上线啦/","link":"","permalink":"http://yoursite.com/2018/04/08/我的博客上线啦/","excerpt":"","text":"使用Hexo+Github page 搭建的个人博客上线了，后续会在上面书写我的学习笔记和文章。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]}