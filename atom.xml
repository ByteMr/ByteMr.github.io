<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ansen&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-12T01:23:57.266Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ansen zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJava 2.x 使用总结二</title>
    <link href="http://yoursite.com/2018/04/10/RxJava%202.x-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/04/10/RxJava 2.x-使用总结二/</id>
    <published>2018-04-10T09:42:21.000Z</published>
    <updated>2018-04-12T01:23:57.266Z</updated>
    
    <content type="html"><![CDATA[<p>传送门:<a href="https://bytemr.github.io/2018/04/10/RxJava%202.x%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E4%B8%80/" target="_blank" rel="noopener">RxJava 2.x 使用总结&lt;一&gt;</a></p><hr><h2 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h2><p>interval操作符是每隔一段时间就产生一个数字，这些数字从0开始，一次递增1直至无穷大，这个间隔时间可以设置，时间单位也可以设置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Thread : "</span>+Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">final</span> Observable&lt;Long&gt; observable = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Consumer.accept :  value = "</span>+value+<span class="string">" , Thread = "</span>+Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的代码执行结果为:</p><pre><code>Thread : mainConsumer.accept :  value = 0 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 1 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 2 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 3 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 4 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 5 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 6 , Thread = RxComputationThreadPool-1...此处省略N行打印</code></pre><p>  通过上面打印我们可以看到使用interval(…)方法，会按照该方法传递的参数值，第一个参数为时间数值，第二个参数为单位，上面的例子为，每个一秒产生一个事件，并传递数值，其数值是从0开始</p><p>递增1的，而且是会无穷大的递增。  </p><p>  然后细心的人可能会发现，上面的打印我是多加了一个对线程名字的打印，我们发现，我们在主线程中建立订阅关系，然后事件的接受消费是在一个名字为RxComputationThreadPool-1中执行的，其实这个线程就是一个子线程，其实很正常啊，我们在项目开发中，执行定时任务或者或者间隔任务，其实都是一种耗时任务，会阻塞的，所以都会放在子线程中去执行的。</p><h2 id="take方法妙用"><a href="#take方法妙用" class="headerlink" title="take方法妙用"></a>take方法妙用</h2><p>结合上面的interval方法，我们在添点油加点醋。我们先来看个例子，应该就最能清楚take的具体作用了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Thread : "</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">final</span> Observable&lt;Long&gt; observable = Observable.interval(<span class="number">1</span>,TimeUnit.SECONDS).take(<span class="number">5</span>);</span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Consumer.accept :  value = "</span> + value+ <span class="string">" , Thread = "</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们可以看到，我们调用了take(5)方法，传递了一个参数5。我们来直接看看运行结果吧。</p><pre><code>Thread : mainConsumer.accept :  value = 0 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 1 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 2 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 3 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 4 , Thread = RxComputationThreadPool-1</code></pre><p>我们可以看到，我们运行结果只打印了五个数值，从0-4，也就是我们调用take(5),其实起作用，大家也不言而喻了吧。</p><h2 id="重复发送的repeat"><a href="#重复发送的repeat" class="headerlink" title="重复发送的repeat"></a>重复发送的repeat</h2><p>再接上面的例子，我们再继而调用一下repeat方法，看看会有什么结果呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Thread : "</span>+Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">final</span> Observable&lt;Long&gt; observable = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS).take(<span class="number">4</span>).repeat(<span class="number">2</span>);</span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Consumer.accept :  value = "</span>+value+<span class="string">" , Thread = "</span>+Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行结果会如何呢？  </p><pre><code>Thread : mainConsumer.accept :  value = 0 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 1 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 2 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 3 , Thread = RxComputationThreadPool-1Consumer.accept :  value = 0 , Thread = RxComputationThreadPool-2Consumer.accept :  value = 1 , Thread = RxComputationThreadPool-2Consumer.accept :  value = 2 , Thread = RxComputationThreadPool-2Consumer.accept :  value = 3 , Thread = RxComputationThreadPool-2</code></pre><p>由此可见，打印0-3重复了2一遍，那也就是我们调用repeat(2)其到了作用，我们知道不调用这个方法，我们只会打印一遍。</p><h2 id="range方法发送特定的整数序列"><a href="#range方法发送特定的整数序列" class="headerlink" title="range方法发送特定的整数序列"></a>range方法发送特定的整数序列</h2><blockquote><p>range可以创建发射特定整数序列的 Observable。</p><blockquote><p>range( int start , int end ) //start :开始的值 ， end ：结束的值</p><blockquote><p>要求： end &gt;= start</p></blockquote></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">1</span>, <span class="number">5</span>).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Consumer.accept : value = "</span>+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看看执行结果：</p><pre><code>Consumer.accept : value = 1Consumer.accept : value = 2Consumer.accept : value = 3Consumer.accept : value = 4Consumer.accept : value = 5</code></pre><p>很明显，打印了从1-5的连续的整数序列。</p><h2 id="flatMap-方法"><a href="#flatMap-方法" class="headerlink" title="flatMap 方法"></a>flatMap 方法</h2><p>flatMap是变换操作符，使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后flatMap合并这些Observable发射的数据，最后将合并后的结果当作它自己的数据序列发射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">emitter.onNext(<span class="number">1</span>);</span><br><span class="line">emitter.onNext(<span class="number">2</span>);</span><br><span class="line">emitter.onNext(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).flatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer value)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"flatMap.apply.value = "</span>+value);</span><br><span class="line"><span class="keyword">if</span>(value ==<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> Observable.just(<span class="string">"One"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value ==<span class="number">2</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> Observable.just(<span class="string">"Two"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value ==<span class="number">3</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> Observable.just(<span class="string">"Three"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> Observable.just(<span class="string">"Unknow"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Consumer.accept :  content = "</span>+content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们来看看执行结果吧：</p><pre><code>flatMap.apply.value = 1Consumer.accept :  content = OneflatMap.apply.value = 2Consumer.accept :  content = TwoflatMap.apply.value = 3Consumer.accept :  content = Three</code></pre><p>通过结果，表面上看起来和map没有什么区别，map是可以在apply方法中直接返回转换后的数据，但是在flatMap中，是必须返回一个独立的ObservableSource对象的，我们知道Observable是继承自ObservableSource的。</p><p>我们就flatMap方法，我们再来看一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    emitter.onNext(<span class="number">1</span>);</span><br><span class="line">    emitter.onNext(<span class="number">2</span>);</span><br><span class="line">    emitter.onNext(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).flatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer value)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"flatMap.apply.value = "</span>+value);</span><br><span class="line"><span class="keyword">if</span>(value ==<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> Observable.just(<span class="string">"One"</span>).delay(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value ==<span class="number">2</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> Observable.just(<span class="string">"Two"</span>).delay(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value ==<span class="number">3</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> Observable.just(<span class="string">"Three"</span>).delay(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="string">"Unknow"</span>).delay(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Consumer.accept :  content = "</span>+content+<span class="string">" , Thread : "</span>+Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码，我们调用了delay，延时，我们先看结果。</p><pre><code>flatMap.apply.value = 1flatMap.apply.value = 2flatMap.apply.value = 3Consumer.accept :  content = Three , Thread : RxNewThreadScheduler-3Consumer.accept :  content = Two , Thread : RxNewThreadScheduler-2Consumer.accept :  content = One , Thread : RxNewThreadScheduler-1</code></pre><p>可以看到先打印了Three，然后是Two，最后是One，和之前的结果不一样了，而且线程都不同的子线程(如果不调用delay的话，默认都在订阅所在线程)，顺序改变了，可是有时候，我们需要延时，却并不要，改变执行顺序，依然需要One、Two、Three…这样的一个顺序，那么我们该怎么办？接下来我们需要讲讲concatMap操作。</p><h2 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h2><p>我们上一个话题说到使用flatMap操作时候，如果最终转换出来的Observable是调用了delay的话且又都在不同的线程，如何去保证原始顺序呢？<br>所以我们才需要concatMap这个方法，其实简答的来说，concatMap和flatMap的区别就在于，concatMap保证了其事件派发的顺序。</p><p>这里我们其他地方都不改动，直接把flatMap替换成concatMap再来看看结果吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    emitter.onNext(<span class="number">1</span>);</span><br><span class="line">    emitter.onNext(<span class="number">2</span>);</span><br><span class="line">    emitter.onNext(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).concatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(Integer value)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"flatMap.apply.value = "</span>+value);</span><br><span class="line">    <span class="keyword">if</span>(value ==<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> Observable.just(<span class="string">"One"</span>).delay(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value ==<span class="number">2</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> Observable.just(<span class="string">"Two"</span>).delay(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value ==<span class="number">3</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> Observable.just(<span class="string">"Three"</span>).delay(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Observable.just(<span class="string">"Unknow"</span>).delay(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Consumer.accept :  content = "</span>+content+<span class="string">" , Thread : "</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>那么接下来，我们直接看看运行效果呗。  </p><pre><code>flatMap.apply.value = 1Consumer.accept :  content = One , Thread : RxComputationThreadPool-1flatMap.apply.value = 2Consumer.accept :  content = Two , Thread : RxComputationThreadPool-2flatMap.apply.value = 3Consumer.accept :  content = Three , Thread : RxComputationThreadPool-3</code></pre><p>OK，结果非常明显，不管delay如何变化，都能保证了顺序。</p><h2 id="fromIterable"><a href="#fromIterable" class="headerlink" title="fromIterable"></a>fromIterable</h2><p>有这样一个使用场景，假设我们发射一个list格式的数据，Observer需要逐一去接收list中的数据并作出相应的操作，像这种场景我们该如何实现呢？</p><p>不管三七二十一，我们先来看一段代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;List&lt;String&gt;&gt; emitter)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"A"</span>);</span><br><span class="line">list.add(<span class="string">"B"</span>);</span><br><span class="line">list.add(<span class="string">"C"</span>);</span><br><span class="line">list.add(<span class="string">"D"</span>);</span><br><span class="line">emitter.onNext(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).flatMap(<span class="keyword">new</span> Function&lt;List&lt;String&gt;, ObservableSource&lt;String&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">apply</span><span class="params">(List&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Observable.fromIterable(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Consumer.accept : content = "</span>+content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的代码，我们可以看到，我们发射一个list集合，然后我们使用拿到集合之后，使用flatMap重新进行了转换，我们发现我们直接调用了Observable的fromIterable方法，传入list集合，最后，我们在接收的时候，就跟遍历list集合一样，逐一的打印了list集合中的数据，但是当然你如果有其他的附件操作也是可以的。</p><p>与fromIterable异曲同工之妙的<strong>fromArray</strong> 其实效果是一样的，只不过，Observalbe原始发射的是一个数组，这里就不在讲述其使用方法了。</p><p>既然讲到数组集合了，那么我们接下来也应该说一说<strong>toList</strong> 了</p><h2 id="toList"><a href="#toList" class="headerlink" title="toList"></a>toList</h2><p>这个就比较简单了，从字面上来说，无非就是把一组数据，转成一个集合？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.just(<span class="string">"item1"</span>, <span class="string">"item2"</span>, <span class="string">"item3"</span>, <span class="string">"item4"</span>, <span class="string">"item5"</span>)</span><br><span class="line">.toList()</span><br><span class="line">.subscribe(<span class="keyword">new</span> Consumer&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(List&lt;String&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Consumer.accept :  list = "</span>+list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>就直接看结果吧。</p><pre><code>Consumer.accept :  list = [item1, item2, item3, item4, item5]</code></pre><p>很显然，直接将一组数据转成了一个list发射。</p><h2 id="背压-BackPressure"><a href="#背压-BackPressure" class="headerlink" title="背压 BackPressure"></a>背压 BackPressure</h2><p><strong>背压产生的原因：</strong>  </p><blockquote><p>被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。在 Rxjava 1.x 版本很容易就会报错，使程序发生崩溃。</p></blockquote><pre><code>...Caused by: rx.exceptions.MissingBackpressureException......</code></pre><p>我们知道在RxJava 1.x中是不支持背压的，但是在2.X之后支持背压了，可是在Observable和Observer依然还是不支持，不过2.X增加了Flowable（被观察者），Flowable （被观察者）和Subscriber （观察者）配合可以完美实现背压处理。</p><p>先来看一段不使用背压处理时候的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .subscribeOn(Schedulers.io())</span><br><span class="line">  .observeOn(Schedulers.newThread())</span><br><span class="line">  .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"value : "</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码中，发射器发射数据的频率为1毫秒，而消费者以1秒处理一个事件的能力在处理，很显然，这会导致RxJava对已经发射出去且未被处理的数据进行了缓存，都存在于内存中，这样一段代码在执行的时候并不会报错，因为这样的组合并不支持背压，并不会抛出MissingBackpressureException背压异常，但是这样的代码其实有很大的问题的。</p><ol><li>存在延迟缓存的话，会导致无法即使处理关键、敏感、重要信息。</li><li>如果数据量不确定，可能比较大的情况下，都缓存在内存中的话，会占用大量的内存，是不明智的做法。</li></ol><p>然后我们如何通过背压处理来解决呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flowable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(Schedulers.newThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Consumer.accept: value = "</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p><p>我们知道RxJava 2.X中Flowable支持了背压，可是上面的代码然后就解决问题了吗?运行结果会如何呢？</p><pre><code>io.reactivex.exceptions.OnErrorNotImplementedException: Can&apos;t deliver value 128 due to lack of requests......Caused by: io.reactivex.exceptions.MissingBackpressureException:     Can&apos;t deliver value 128 due to lack of requests</code></pre><p>很明显发生了 MissingBackpressureException 异常 , 128 代表是 Flowable 最多缓存 128 个数据，缓存次超过 128 个数据，就会报错。可喜的是，Rxjava 已经给我们提供了解决背压的策略。  </p><h3 id="背压策略onBackpressureDrop"><a href="#背压策略onBackpressureDrop" class="headerlink" title="背压策略onBackpressureDrop"></a>背压策略onBackpressureDrop</h3><blockquote><p>onBackpressureDrop() ：当缓冲区数据满 128             个时候，再新来的数据就会被丢弃，如果此时有数据被消费了，那么就会把当前最新产生的数据，放到缓冲区。简单来说 Drop 就是直接把存不下的事件丢弃。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flowable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">.onBackpressureDrop()</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(Schedulers.newThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Consumer.accept: value = "</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码，我们调用了onBackpressureDrop()方法，然后来看看结果。</p><pre><code>...Consumer.accept: value = 124Consumer.accept: value = 125Consumer.accept: value = 126Consumer.accept: value = 127Consumer.accept: value = 96093Consumer.accept: value = 96094Consumer.accept: value = 96095Consumer.accept: value = 96096Consumer.accept: value = 96097...</code></pre><p>我们发现发射器发射的 0 ~ 127 总共 128 个数据是连续的，下一个数据就是 96129 ， 128 ~ 96128 的数据被丢弃了。<br>onBackpressureDrop的调用 一定要放在 interval 后面否则不会生效。</p><h3 id="onBackpressureBuffer"><a href="#onBackpressureBuffer" class="headerlink" title="onBackpressureBuffer"></a>onBackpressureBuffer</h3><blockquote><p>onBackpressureBuffer：默认情况下缓存所有的数据，不会丢弃数据，这个方法可以解决背压问题，但是它有像 Observable 一样的缺点，缓存数据太多，占用太多内存。<br>onBackpressureBuffer(int capacity) ：设置缓存队列大小，但是如果缓冲数据超过了设置的值，就会报错，发生崩溃。</p></blockquote><p>示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flowable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">.onBackpressureBuffer(<span class="number">20</span>)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(Schedulers.newThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"Consumer.accept: value = "</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>执行结果:</p><p>io.reactivex.exceptions.OnErrorNotImplementedException: Buffer is full<br>···<br>Caused by: io.reactivex.exceptions.MissingBackpressureException: Buffer is full<br>通过日志可以看出，缓冲区已经满了，抛出了异常。</p><h2 id="Subscriber-Flowable处理背压和Subscription-request-long-count-方法"><a href="#Subscriber-Flowable处理背压和Subscription-request-long-count-方法" class="headerlink" title="Subscriber + Flowable处理背压和Subscription.request(long count)方法"></a>Subscriber + Flowable处理背压和Subscription.request(long count)方法</h2><p>先来看一段代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"subscribe"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">201</span> ; i++) &#123;</span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.DROP).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onSubscribe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onNext:integer = "</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onError "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onComplete "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的代码，有些人是不是觉得，会直接打印0-127的打印？可是万万没想到的是，只是打印了如下两个日志。</p><pre><code>onSubscribesubscribe</code></pre><p>那么如何才能接收到发射的事件，然后打印出来呢？那么就需要用到Subscription的request(…)方法了。那么Subscription从哪里来呢？<br>细心的人可能发现了，在onSubscribe(Subscription s)回调方法中，传递了一个Subscription s对象，那么我们直接在这个回调方法中调用s.request(50);方法试试看有什么效果吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(FlowableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"subscribe"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">201</span> ; i++) &#123;</span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, BackpressureStrategy.DROP).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onSubscribe"</span>);</span><br><span class="line">    s.request(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onNext:integer = "</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onError "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"onComplete "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到，我们在onSubscribe回调方法中调用了s.request(10);来看看其结果吧！</p><pre><code>onSubscribesubscribeonNext:integer = 0onNext:integer = 1onNext:integer = 2onNext:integer = 3onNext:integer = 4onNext:integer = 5onNext:integer = 6onNext:integer = 7onNext:integer = 8onNext:integer = 9</code></pre><p>结果我们发现，你请求多少个数据事件，就会给你发射多少个数据事件，这样我们才能接收到数据并消费数据。</p><p>那么我们拿到这个Subscription对象之后，在外部再调用一次request(10)呢？</p><pre><code>onSubscribesubscribeonNext:integer = 0onNext:integer = 1onNext:integer = 2onNext:integer = 3onNext:integer = 4onNext:integer = 5onNext:integer = 6onNext:integer = 7onNext:integer = 8onNext:integer = 9onNext:integer = 10onNext:integer = 11onNext:integer = 12onNext:integer = 13onNext:integer = 14onNext:integer = 15onNext:integer = 16onNext:integer = 17onNext:integer = 18onNext:integer = 19</code></pre><p>我们发现我们是从第一次调用request(10)之后，又接收消费了从9-19的数据事件，那么我们从中得到的规律是，每次调用request(..)方法，都会从上一次发射的最后一个事件的下一个事件开发发送请求数量的事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传送门:&lt;a href=&quot;https://bytemr.github.io/2018/04/10/RxJava%202.x%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E4%B8%80/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 2.x 使用总结&lt;一&gt;</title>
    <link href="http://yoursite.com/2018/04/10/RxJava%202.x%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <id>http://yoursite.com/2018/04/10/RxJava 2.x 使用总结一/</id>
    <published>2018-04-10T01:58:17.000Z</published>
    <updated>2018-04-11T11:00:47.102Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录一下RxJava2.x的使用，其实网络上已经有很多关于RxJava的使用教程，以及原理剖析类的文章，其实我的理解大概也和那些文章中描述的也差不多，所以这里就不在过多去说类似的东西了。</p><p>在这里推荐一篇文章给大家，虽然是基于RxJava 1.X来写的，但是我觉得这是我目前见过写的比较清晰了然的一片文章，很适合初学者去对RxJava进行一番学习和使用。  </p><p><a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>  </p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'io.reactivex.rxjava2:rxjava:2.1.12'</span></span><br><span class="line">implementation <span class="string">'io.reactivex.rxjava2:rxandroid:2.0.2'</span></span><br><span class="line">implementation <span class="string">'org.reactivestreams:reactive-streams:1.0.2'</span></span><br><span class="line">implementation <span class="string">'com.squareup.okhttp3:okhttp:3.10.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:retrofit:2.4.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.4.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.okhttp3:logging-interceptor:3.10.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-scalars:2.4.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:adapter-rxjava2:2.4.0'</span></span><br></pre></td></tr></table></figure><p>当然，上面添加的依赖有点多，但是其实你如果只需要使用RxJava只需要添加如下两个依赖就行 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'io.reactivex.rxjava2:rxjava:2.1.12'</span></span><br><span class="line">implementation <span class="string">'org.reactivestreams:reactive-streams:1.0.2'</span></span><br></pre></td></tr></table></figure></p><p>但是你如果想要在android上面使用的话，就必须再多加上如下这个依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'io.reactivex.rxjava2:rxandroid:2.0.2'</span></span><br></pre></td></tr></table></figure></p><p>我们知道现在主流用发就是，RxJava+OkHttp+Retrofit，这三者结合使用是让我们的代码更加简单有层次，提升性能有提升开发速度，所以你如果又要在你的项目中需要请求网络，需要传输json数据的话，不妨再加上如下几个依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.okhttp3:okhttp:3.10.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:retrofit:2.4.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.4.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.okhttp3:logging-interceptor:3.10.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-scalars:2.4.0'</span></span><br><span class="line">implementation <span class="string">'com.squareup.retrofit2:adapter-rxjava2:2.4.0'</span></span><br></pre></td></tr></table></figure></p><h2 id="使用create-…-创建Observable"><a href="#使用create-…-创建Observable" class="headerlink" title="使用create(…)创建Observable"></a>使用create(…)创建Observable</h2><p>create(…)方法是Observable对象的一个静态方法，主要用于创建产生一个Observable被观察者对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123;</span><br><span class="line">    emitter.onNext(&quot;Hello!&quot;);</span><br><span class="line">    emitter.onNext(&quot;RxJava&quot;);</span><br><span class="line">    emitter.onNext(&quot;Hi!&quot;);</span><br><span class="line">    emitter.onNext(&quot;Android&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的代码我们使用create(…)方法创建了一个被观察者Observable，那么我们知道观察者Observer和被观察者Observable之间事件的订阅关系是通过subscribe(…)方法来实现的，一般来说，订阅事件是发生在观察者身上的，因为观察者需要关注订阅发生在被观察者身上的一系列事件，但是在RxJava中，为了方便链式的调用以及RxJava的架构，这个subscribe(…)方法声明在了Observable对象上，现在我们先来创建一个观察者Observer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onSubscribe(Disposable disposable) &#123;</span><br><span class="line">System.out.println(&quot;Observer.onSubscribe :  isDisposable = &quot;  +disposable.isDisposed());</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onNext(String content) &#123;</span><br><span class="line">System.out.println(&quot;Observer.onNext :  content = &quot;  +content);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onError(Throwable throwable) &#123;</span><br><span class="line">System.out.println(&quot;Observer.onError &quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void onComplete() &#123;</span><br><span class="line">System.out.println(&quot;Observer.onComplete &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Observer我们创建好了，我们发现需要Override四个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onSubscribe(Disposable disposable)；</span><br><span class="line">public void onNext(String content) ；</span><br><span class="line">public void onError(Throwable throwable)；</span><br><span class="line">public void onComplete()；</span><br></pre></td></tr></table></figure></p><p>但是细心的就会发现，我们Observable持有的一个发射器ObservableEmitter，这个对象也有三个比较关键的方法。  </p><p>不然发现，是onNext()、onError()、onComplete()三个方法，看起来是和Observer中其中的三个需要Override的方法是对应的。</p><p>这样我就把观察者Observer和被观察者Observable创建好了，接下来要做的就是使用subscribe(…)方法把他们关联起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p><p>OK，这就把两者的关系给绑定起来了，另外要注意的是，这个方法一旦调用，也就是说，一旦注册订阅，被观察着的事件发射器就开发发射事件，接着观察者的方法就会被被调用。<br>代码的运行结果吧！</p><pre><code>Observer.onSubscribe :  isDisposable = falseObserver.onNext :  content = Hello!Observer.onNext :  content = RxJavaObserver.onNext :  content = Hi!Observer.onNext :  content = Android</code></pre><p>从上面的打印来看，当订阅成功后，会立马先调用Observer的onSubscribe方法，然后会依次按顺序打印了Hello!-&gt;RxJava-&gt;Hi!-&gt;Android  </p><p>从上面的代码中，我们知道，和1.x想比，2.X多了一个<strong>Disposable</strong>，我们可以看到在onSubscribe()方法中会传递过来一个Disposable对象，那么这个Disposable其实可以看做是连接Observer和Observable的一个开关，拿到它之后，可以直接调用切断，来解除Observer对Observable的关注和订阅，但是这也意味着，Observer不在能收到订阅事件了，所以Disposable的dispose()方法就可以切断两者的事件驱动，当Disposable的isDisposed()方法返回false的时候，表明正常，可以发送接收事件，但是为true的时候，表明两者事件驱动被切断。  </p><h2 id="调用onComplete-会如何？"><a href="#调用onComplete-会如何？" class="headerlink" title="调用onComplete()会如何？"></a>调用onComplete()会如何？</h2><p>我们发现上面的实例代码中，仅仅只是调用了onNext(…)方法触发了四个事件，然后Observer接收处理了相应的事件，我们稍微改动一下代码，然后在我们的代码中调用一下onComplete()看看会有什么效果呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123;</span><br><span class="line">emitter.onNext(&quot;Hello!&quot;);</span><br><span class="line">emitter.onNext(&quot;RxJava&quot;);</span><br><span class="line">emitter.onComplete();</span><br><span class="line">emitter.onNext(&quot;Hi!&quot;);</span><br><span class="line">emitter.onNext(&quot;Android&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们看到，在subscribe(…)方法中，我在四个onNext()调用顺序之间加了一句代码，即调用了oComplete方法，然后我们再来执行一下代码，看看会有什么结果。</p><pre><code>Observer.onSubscribe :  isDisposable = falseObserver.onNext :  content = Hello!Observer.onNext :  content = RxJavaObserver.onComplete </code></pre><p>结果，我们发现，我们只收到了调用onComplete()方法之前的两个onNext事件，然后就直接执行了Observer的onComplete()方法，由此可知，当调用发射器的onComplete()方法之后，后面的事件是无法再收到了，但是事件的发送还在继续。  </p><h2 id="简化的Consumer"><a href="#简化的Consumer" class="headerlink" title="简化的Consumer"></a>简化的Consumer</h2><p>有时候我们觉得使用Observer比较复杂，我们知道Observer是一个接口，如果要实现Observer接口，那么必须覆盖其四个抽象方法，比如有些时候我们只关注订阅的事件，只对订阅的事件的发生做出<br>相应的操作，那么一般我们只需要Override  onNext(…){}即可。  </p><p>如果说RxJava中两个重要的角色关系是观察者和被观察的关系的话，被观察者产生事件，观察者响应事件，那么是不是也可以理解为这是一种生产者和消费者的关系，很显然这么理解是可以的。  </p><p>所以RxJava中有一个用起来比简单的Consumer，实现Consumer 接口只需要实现一个方法，即accept(…)，当然Observable和Consumer之间也是通过Observable的subscribe来建立订阅关系的，OK我们之间写一段代码来运行试试看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123;</span><br><span class="line">emitter.onNext(&quot;Hello!&quot;);</span><br><span class="line">emitter.onNext(&quot;RxJava&quot;);</span><br><span class="line">emitter.onComplete();</span><br><span class="line">emitter.onNext(&quot;Hi!&quot;);</span><br><span class="line">emitter.onNext(&quot;Android&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">final Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(String content) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Consumer.accept : content = &quot;+content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">final Disposable disposable = observable.subscribe(consumer);</span><br></pre></td></tr></table></figure></p><p>我们的Observable没有变，还有前面创建的对象，我们来试试运行结果。</p><pre><code>Consumer.accept : content = Hello!Consumer.accept : content = RxJava</code></pre><p>我们发现Consumer的accept()方法只调用了两次，只打印了“Hello！” 和 “RxJava”，和使用Observer的不同之处在于，Observer会关注Observable的任何一个操作，比如，onError()、onComplete()方法，而Consumer就比较简单了，只需要关注和响应onNext(…)事件就行了，有时候我们可能就只需这样简单的场景，当然这是RxJava 2.x出现的特性。</p><p>但是我们还发现，使用订阅Consumer的时候，会直接返回一个Disposable对象。</p><h2 id="事件的转换包装器map"><a href="#事件的转换包装器map" class="headerlink" title="事件的转换包装器map"></a>事件的转换包装器map</h2><p>先不说map的功能，我们先直接看一段代码，再来谈谈map的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123;</span><br><span class="line">emitter.onNext(100);</span><br><span class="line">emitter.onNext(200);</span><br><span class="line">emitter.onNext(300);</span><br><span class="line">emitter.onNext(400);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String apply(Integer num) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Function.apply : num = &quot;+num);</span><br><span class="line">return &quot;我得了&quot;+num+&quot;分&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(String content) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Consumer.accept : content = &quot;+content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行结果: </p><pre><code>Function.apply : num = 100Consumer.accept : content = 我得了100分Function.apply : num = 200Consumer.accept : content = 我得了200分Function.apply : num = 300Consumer.accept : content = 我得了300分Function.apply : num = 400Consumer.accept : content = 我得了400分</code></pre><p>可以看到，是先执行了map节点中Function对象的apply方法，这个方法接收一个Integer类型的数据，然后返回一个String类型的数据，继apply(…)方法之后是Consumer的accept(…)方法，而accept收到的参数是一个String类型，其值就是通过Function对象的apply方法返回来的。  </p><p>那么不难发现，我们可以把map节点中的Function看做一个工厂，把Integer泛型限定的Observable(Observable(Integer))转换成了String类型的Observable(Observable<string>)。</string></p><p>其实我们把每个节点分开来写会更加清晰一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123;</span><br><span class="line">emitter.onNext(100);</span><br><span class="line">emitter.onNext(200);</span><br><span class="line">emitter.onNext(300);</span><br><span class="line">emitter.onNext(400);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>不难发现，首先初始是一个Observable<integer>类型的，当我们调用起map方法之后就变成了Observable<string>类型了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;String&gt; observable2 = observable.map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public String apply(Integer num) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Function.apply : num = &quot;+num);</span><br><span class="line">return &quot;我得了&quot;+num+&quot;分&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></string></integer></p><p>最后再调用了subscribe方法进行关联订阅。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">observable2.subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(String content) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Consumer.accept : content = &quot;+content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>所以通过上面的一个小例子，我们不难发现，map基本作用就是将一个 Observable 通过某种函数关系，转换为另一种 Observable，上面例子中就是把我们的 Integer 数据变成了 String 类型。</p><h2 id="事件组合器zip"><a href="#事件组合器zip" class="headerlink" title="事件组合器zip"></a>事件组合器zip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;Integer&gt; integerObservable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;Integer&gt; emitter)throws Exception &#123;</span><br><span class="line">emitter.onNext(100);</span><br><span class="line">emitter.onNext(80);</span><br><span class="line">emitter.onNext(60);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">final Observable&lt;String&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123;</span><br><span class="line">emitter.onNext(&quot;优&quot;);</span><br><span class="line">emitter.onNext(&quot;良&quot;);</span><br><span class="line">emitter.onNext(&quot;及格&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">final Observable&lt;String&gt; resultObservable = Observable.zip(integerObservable,stringObservable, new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public String apply(Integer score, String desc)throws Exception &#123;</span><br><span class="line">System.out.println(&quot;&lt;zip&gt;.BiFunction.apply : score = &quot;+score+&quot; , desc = &quot;+desc);</span><br><span class="line">return score +&quot; 分为 &quot;+ desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">resultObservable.subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(String content) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;Consumer.accept : content = &quot;+content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么直接看结果。</p><pre><code>&lt;zip&gt;.BiFunction.apply : score = 100 , desc = 优Consumer.accept : content = 100 分为 优&lt;zip&gt;.BiFunction.apply : score = 80 , desc = 良Consumer.accept : content = 80 分为 良&lt;zip&gt;.BiFunction.apply : score = 60 , desc = 及格Consumer.accept : content = 60 分为 及格</code></pre><p>我们发现，通过调用Observable的zip(…)方法，方法最后的以参数为一个BiFunction对象，很巧妙的将两个事件进行组合，组合成了一个新的Observable<string>。</string></p><p>zip 组合事件的过程就是分别从integerObservable和stringObservable各取出一个事件来组合，并且一个事件只能被使用一次，组合的顺序是严格按照事件发送的顺序来进行的，所以上面的实例可以看到，100 永远和 “优”结合，80永远和“良”结合等。  </p><p>那么会有一个问题，如果我在integerObservable中发送三个事件，在stringObservable发送一个或者两个，或者三个，甚至一个都不发呢?这种情况是如何执行的呢？不妨来来试试看吧，我们改动一下stringObservable里面的逻辑吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;String&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123;</span><br><span class="line">emitter.onNext(&quot;优&quot;);</span><br><span class="line">emitter.onNext(&quot;良&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>执行结果如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;zip&gt;.BiFunction.apply : score = 100 , desc = 优</span><br><span class="line">Consumer.accept : content = 100 分为 优</span><br><span class="line">&lt;zip&gt;.BiFunction.apply : score = 80 , desc = 良</span><br><span class="line">Consumer.accept : content = 80 分为 良</span><br></pre></td></tr></table></figure></p><p>我们发现少了一个60和”及格”的组合。<br>然后我们全部去掉，什么都不发送呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Observable&lt;String&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void subscribe(ObservableEmitter&lt;String&gt; emitter)throws Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>再执行，我们发现，什么打印都没有。所以我们可以总结为最终接收到的事件数量是和发送事件最少的那个Observable发送器的发送事件数目相同，如果其中一个什么都没发送，那么什么事件都接收不到。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要记录一下RxJava2.x的使用，其实网络上已经有很多关于RxJava的使用教程，以及原理剖析类的文章，其实我的理解大概也和那些文章中描述的也差不多，所以这里就不在过多去说类似的东西了。&lt;/p&gt;
&lt;p&gt;在这里推荐一篇文章给大家，虽然是基于RxJava 1.X来写的，
      
    
    </summary>
    
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+Github搭建个人博客</title>
    <link href="http://yoursite.com/2018/04/09/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/04/09/使用Hexo-Github搭建个人博客/</id>
    <published>2018-04-09T03:47:12.000Z</published>
    <updated>2018-04-09T07:02:14.781Z</updated>
    
    <content type="html"><![CDATA[<p>本篇不在介绍Hexo和Github以及Github pages相关的东西，直接介绍我搭建的每一个步骤，如果想要了解Hexo和Github这块的东西，可以自行去百度或者google了解。</p><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><ol><li><p><strong>安装node.js</strong><br> 直接去官网下载即可。<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a>,<br> node.js在我们的博客搭建过程主要提供包管理服务，<br> Node.js的包管理器npm，是全球最大的开源库生态系统。</p></li><li><p><strong>安装Git</strong><br> 直接官网下载即可。<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br> Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地<br> 处理任何或小或大的项目，版本控制。</p></li><li><p><strong>进入Node.js的根目录，执行如下命令安装Hexo</strong><br><code>npm install hexo -g</code></p></li><li><p><strong>在磁盘上创建一个目录用来存放Blog的所有文件</strong><br> 例如 <code>E:\blog\MrByte</code></p></li><li><p><strong>在步骤4中创建的目录中执行如下命令初始化Blog</strong><br><code>hexo init</code></p></li><li><strong>安装依赖包</strong><br><code>npm install</code></li><li><strong>测试-创建一个篇新的博客</strong><br><code>hexo new &quot;My New Post&quot;</code></li><li><strong>启动服务并测试本地发布</strong><br>执行命令:<br><code>hexo server</code><br>在浏览器输入敲回车:    <code>http://localhost:4000</code></li><li><p><strong>搭桥到github</strong>  </p><p> <strong>A、</strong>创建一个repository，其中[repository name]的格式必须如下:  </p><pre><code>例如: yourname.github.io  其中yourname部分必须和github账号名一致，否则无效。  </code></pre><p> <strong>B、</strong>打开git bash命令行窗口，配置github账号信息,执行如下两条命令<br><code>git config --global user.name &quot;yourName&quot;</code><br><code>git config --global user.email &quot;yourEmail&quot;</code><br>把yourName改为github账号，把yourEmail改为注册Github用的邮箱即可。<br> <strong>C、</strong>在git bash命令窗口中执行如下命令创建SSH<br><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><br>然后在生成的id_rsa.pub中复制其全部内容,双引号中的邮箱改为注册Github用的邮箱即可。<br> <strong>D、</strong>然后登入github，选择[Settings]-[SSH and GPG keys]-[New SSH key]  </p><pre><code>然后粘贴上述复制的SSH public key即可。  </code></pre><p> <strong>E、</strong>然后在git bash命令行中执行如下命令行进行验证<br><code>ssh -T git@github.com</code><br> <strong>F、</strong>在blog项目根目录中找到[_config.yml]文件，使用文本编辑器打开,<br>每个字段的冒号后面都有一个空格。 </p><blockquote><p>deploy:<br>type: git<br>repository: <a href="https://ByteMr:******@github.com/ByteMr/ByteMr.github.io.git" target="_blank" rel="noopener">https://ByteMr:******@github.com/ByteMr/ByteMr.github.io.git</a><br>branch: master  </p></blockquote><p> 上述repositoy字段中的地址中，冒号后后面出现*号，这里应该替换成你真实的github账号密码，ByteMr则为真实的github账号</p></li><li><p><strong>上传到github</strong><br><strong>A、</strong>执行如下命令，这样才能将你写好的文章部署到github服务器上并让别人浏览到<br><code>npm install hexo-deployer-git --save</code><br><strong>B、</strong>发布  </p><blockquote><p> hexo clean<br> hexo generate<br> hexo deplo  </p></blockquote></li><li><p><strong>测试是否发布成功</strong><br>浏览器输入：    <a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇不在介绍Hexo和Github以及Github pages相关的东西，直接介绍我搭建的每一个步骤，如果想要了解Hexo和Github这块的东西，可以自行去百度或者google了解。&lt;/p&gt;
&lt;h1 id=&quot;搭建步骤&quot;&gt;&lt;a href=&quot;#搭建步骤&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://yoursite.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>我的博客上线啦</title>
    <link href="http://yoursite.com/2018/04/08/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E5%95%A6/"/>
    <id>http://yoursite.com/2018/04/08/我的博客上线啦/</id>
    <published>2018-04-08T11:06:04.000Z</published>
    <updated>2018-04-09T01:20:37.927Z</updated>
    
    <content type="html"><![CDATA[<p>使用Hexo+Github page 搭建的个人博客上线了，后续会在上面书写我的学习笔记和文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Hexo+Github page 搭建的个人博客上线了，后续会在上面书写我的学习笔记和文章。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
